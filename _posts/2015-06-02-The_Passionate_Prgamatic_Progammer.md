---
layout: post
title: The Passionate Prgmatic Programmer
categories: [5a7]
author: yeljaoujat
tags: [ TDD, Junit, easyMock,PowerMock,Mockito]
fullview: false
---
##Care About Your Craft 2
Why spend your life developing software unless you care about doing it well?

##Think! About Your Work 3
Turn off the autopilot and take control. Constantly critique and appraise your work.

##Provide Options, Don't Make Lame Excuses 5
Instead of excuses, provide options. Don't say it can't be done; explain what can be done.

##Don't Live with Broken Windows 7
Fix bad designs, wrong decisions, and poor code when you see them.

##Be a Catalyst for Change 6
You can't force change on people. Instead, show them how the future might be and help them participate in creating it.

##Remember the Big Picture 5
Don't get so engrossed in the details that you forget to check what's happening around you.

##Make Quality a Requirements Issue 7
Involve your users in determining the project's real quality requirements.

##Invest Regularly in Your Knowledge Portfolio 9
Make learning a habit.

##Critically Analyze What You Read and Hear 7
Don't be swayed by vendors, media hype, or dogma. Analyze information in terms of you and your project.

##It's Both What You Say and the Way You Say It 5
There's no point in having great ideas if you don't communicate them effectively.

##DRY – Don't Repeat Yourself 7
Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

##Make It Easy to Reuse 
If it's easy to reuse, people will. Create an environment that supports reuse.

##Eliminate Effects Between Unrelated Things 3
Design components that are self-contained. independent, and have a single, well-defined purpose.

##There Are No Final Decisions 5
No decision is cast in stone. Instead, consider each as being written in the sand at the beach, and plan for change.


##Use the Power of Command Shells
Use the shell when graphical user interfaces don't cut it.

##Use a Single Editor Well
The editor should be an extension of your hand; make sure your editor is configurable, extensible, and programmable.


##Fix the Problem, Not the Blame 7
It doesn't really matter whether the bug is your fault or someone else's – it is still your problem, and it still needs to be fixed.

##Don't Panic When Debugging 7
Take a deep breath and THINK! about what could be causing the bug.

##"select" Isn't Broken. 5
It is rare to find a bug in the OS or the compiler, or even a third-party product or library. The bug is most likely in the application.

##Learn a Text Manipulation Language.
You spend a large part of each day working with text. Why not have the computer do some of it for you?

##Write Code That Writes Code
Code generators increase your productivity and help avoid duplication.

##You Can't Write Perfect Software
Software can't be perfect. Protect your code and users from the inevitable errors.

##Design with Contracts
Use contracts to document and verify that code does no more and no less than it claims to do.

##Crash Early
A dead program normally does a lot less damage than a crippled one.


##Minimize Coupling Between Modules
Avoid coupling by writing "shy" code and applying the Law of Demeter.

##Configure, Don't Integrate
Implement technology choices for an application as configuration options, not through integration or engineering.

##Put Abstractions in Code, Details in Metadata
Program for the general case, and put the specifics outside the compiled code base.

##Design Using Services
Design in terms of services – independent, concurrent objects behind well-defined, consistent interfaces.

##Always Design for Concurrency
Allow for concurrency, and you'll design cleaner interfaces with fewer assumptions.


##Refactor Early, Refactor Often
Just as you might weed and rearrange a garden, rewrite, rework, and re-architect code when it needs it. Fix the root of the problem.

##Design to Test
Start thinking about testing before you write a line of code.

##Workwith a User to Think Like a User
It's the best way to gain insight into how the system will really be used.

##Abstractions Live Longer than Details
Invest in the abstraction, not the implementation. Abstractions can survive the barrage of changes from different implementations and new technologies.

##Don't Think Outside the Box – Find the Box
When faced with an impossible problem, identify the real constraints. Ask yourself: "Does it have to be done this way? Does it have to be done at all?"

##Some Things Are Better Done than Described
Don't fall into the specification spiral – at some point you need to start coding.

##Don't Be a Slave to Formal Methods.
Don't blindly adopt any technique without putting it into the context of your development practices and capabilities.

##Don't Use Manual Procedures
A shell script or batch file will execute the same instructions, in the same order, time after time.

##Test Early. Test Often. Test Automatically
Tests that run with every build are much more effective than test plans that sit on a shelf.

##Coding Ain't Done 'Til All the Tests Run
'Nuff said.

##Find Bugs Once
Once a human tester finds a bug, it should be the last time a human tester finds that bug. Automatic tests should check for it from then on.

##Build Documentation In, Don't Bolt It On
Documentation created separately from code is less likely to be correct and up to date.

##Gently Exceed Your Users' Expectations
Come to understand your users' expectations, then deliver just that little bit more.

##Sign Your Work
Craftsmen of an earlier age were proud to sign their work. You should be, too.